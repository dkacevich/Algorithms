def unbounded_knapsack(W, n, val, wt):

    # ініціалізація dp
    # масив, який зберігає максимальне значення,
    # яке можна отримати для кожної вмістимості рюкзака від 0 до W
    dp = [0 for i in range(W + 1)]
    
    
    # масив, який зберігає індекс предмета,
    # який був взятий останнім для кожної вмістимості рюкзака
    item_count = [0 for i in range(W + 1)]

    # Для кожної вмістимості рюкзака від 0 до W, ми перевіряємо кожен предмет
    for i in range(W + 1):
        for j in range(n):
            
            # Якщо вага предмета менша або дорівнює вмістимості рюкзака
            if (wt[j] <= i) and (dp[i - wt[j]] + val[j] > dp[i]):
                
                # оновлюємо dp[i] максимальним значенням між поточним значенням dp[i] та сумою значення предмета та dp[i - wt[j]]
                dp[i] = dp[i - wt[j]] + val[j]
                item_count[i] = j


    # Ініціалізація масиву нулями
    items_taken = [0]*n
    i = W
    
    # Потім ми починаємо з вмістимості рюкзака W і відстежуємо назад,
    # використовуючи масив item_count, щоб знайти, які предмети були взяті.
    while i > 0:
        
        # Кожен раз, коли ми знаходимо предмет,
        # ми зменшуємо вмістимість рюкзака на вагу цього предмета 
        # і збільшуємо відповідний елемент в items_taken
        j = item_count[i]
        items_taken[j] += 1
        i -= wt[j]

    return dp[W], items_taken

# Тестові дані
val = [10, 30, 20] # значення предметів
wt = [5, 10, 15] # вага предметів
W = 105 # вмістимість рюкзака

n = len(val)

print(unbounded_knapsack(W, n, val, wt))
